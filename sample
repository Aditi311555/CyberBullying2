from flask import Flask, render_template, request, redirect, session, url_for
import sqlite3
import pickle
import os
import traceback
from werkzeug.security import generate_password_hash, check_password_hash

# -------------- APRIORI IMPORTS ----------------
import pandas as pd
import emoji
from mlxtend.preprocessing import TransactionEncoder
from mlxtend.frequent_patterns import apriori, association_rules
# ------------------------------------------------

app = Flask(__name__)
app.secret_key = "replace_this_with_a_random_secret_in_production"

DB_PATH = "cyberbully.db"
VECT_PATH = "vectorizer.pkl"
MODEL_PATH = "LinearSVCTuned.pkl"
BULLY_LIMIT = 3


# ---------------------------------------------------------------
# --------------------- LOAD ML MODEL ----------------------------
# ---------------------------------------------------------------
if not os.path.exists(VECT_PATH) or not os.path.exists(MODEL_PATH):
    print("ERROR: Model/vectorizer missing!")
    raise SystemExit(1)

try:
    with open(VECT_PATH, "rb") as f:
        vectorizer = pickle.load(f)
    with open(MODEL_PATH, "rb") as f:
        model = pickle.load(f)
except Exception:
    traceback.print_exc()
    raise SystemExit(1)


def predict_is_bullying(text: str) -> bool:
    """Predict using Linear SVC."""
    t = (text or "").strip()
    if t == "":
        return False
    X = vectorizer.transform([t])
    return bool(model.predict(X)[0] == 1)


def get_db():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


# ---------------------------------------------------------------
# --------------------- APRIORI EMOJI MODEL ----------------------
# ---------------------------------------------------------------
# Emojis that always indicate bullying (manual override)
manual_bully_emojis = {"ðŸ¤¬", "ðŸ˜¡", "ðŸ’€", "ðŸ¤£", "ðŸ–•ðŸ»"}

emoji_training_data = [
    ["lol you look stupid ðŸ¤£ðŸ¤£ðŸ’€", "bullying"],
    ["haha you failed ðŸ’€ðŸ’€ðŸ¤£", "bullying"],
    ["you are useless ðŸ¤¬ðŸ˜¡", "bullying"],
    ["shut up ðŸ¤¬ðŸ¤¬", "bullying"],
    ["nice photo ðŸ˜Š", "not_bullying"],
    ["great work ðŸ‘ðŸ”¥", "not_bullying"],
    ["happy birthday ðŸŽ‰ðŸ¥³", "not_bullying"]
]

def extract_emojis(text):
    return [ch for ch in text if ch in emoji.EMOJI_DATA]

df = pd.DataFrame(emoji_training_data, columns=["comment", "label"])
df["emojis"] = df["comment"].apply(extract_emojis)

# Only bullying text emojis
bully_emoji_lists = df[df["label"] == "bullying"]["emojis"].tolist()

# Encode
te = TransactionEncoder()
te_data = te.fit(bully_emoji_lists).transform(bully_emoji_lists)
df_encoded = pd.DataFrame(te_data, columns=te.columns_)

# Find frequent emoji combinations
frequent_sets = apriori(df_encoded, min_support=0.3, use_colnames=True)
rules = association_rules(frequent_sets, metric="confidence", min_threshold=0.6)

# Convert rules to blocked emoji sets
blocked_emoji_sets = [
    frozenset(row["antecedents"]) for _, row in rules.iterrows()
]

print("\nAPR (Apriori) BLOCKED EMOJI SETS:")
print(blocked_emoji_sets, "\n")


def apriori_detect(comment):
    emojis_found = set(extract_emojis(comment))

    # 1ï¸âƒ£ Manual override: single bullying emoji detected
    if manual_bully_emojis.intersection(emojis_found):
        return True, emojis_found, "manual_emoji_detected"

    # 2ï¸âƒ£ Apriori pattern match
    for pattern in blocked_emoji_sets:
        if pattern.issubset(emojis_found):
            return True, emojis_found, pattern

    return False, emojis_found, None



# ---------------------------------------------------------------
# -------------------------- ROUTES -----------------------------
# ---------------------------------------------------------------


@app.route("/register", methods=["GET", "POST"])
def register():
    if request.method == "POST":
        username = request.form.get("username", "").strip()
        password = request.form.get("password", "")

        if not username or not password:
            return render_template("register.html", error="Provide username and password.")

        pw_hash = generate_password_hash(password)

        conn = get_db()
        cur = conn.cursor()
        try:
            cur.execute(
                "INSERT INTO users (username, password_hash) VALUES (?, ?)",
                (username, pw_hash),
            )
            conn.commit()
            conn.close()
            return redirect(url_for("login"))
        except sqlite3.IntegrityError:
            conn.close()
            return render_template("register.html", error="Username already taken.")
    return render_template("register.html")



@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        username = request.form.get("username", "").strip()
        password = request.form.get("password", "")

        conn = get_db()
        cur = conn.cursor()
        cur.execute("SELECT * FROM users WHERE username = ?", (username,))
        user = cur.fetchone()
        conn.close()

        if user and check_password_hash(user["password_hash"], password):
            session["user_id"] = user["id"]
            session["username"] = user["username"]
            return redirect(url_for("index"))

        return render_template("login.html", error="Invalid credentials.")

    return render_template("login.html")



@app.route("/logout")
def logout():
    session.clear()
    return redirect(url_for("login"))



@app.route("/clear_comments")
def clear_comments():
    conn = get_db()
    cur = conn.cursor()
    cur.execute("DELETE FROM comments")
    conn.commit()
    conn.close()
    return "All comments cleared!"



@app.route("/", methods=["GET", "POST"])
def index():

    if "user_id" not in session:
        return redirect(url_for("login"))

    conn = get_db()
    cur = conn.cursor()

    # load user
    cur.execute("SELECT * FROM users WHERE id = ?", (session["user_id"],))
    user = cur.fetchone()

    if not user:
        conn.close()
        session.clear()
        return redirect(url_for("login"))

    if user["is_blocked"]:
        conn.close()
        return render_template("blocked.html", username=user["username"])

    message = None
    prediction = None

    # --------- POST COMMENT ---------
    if request.method == "POST":
        text = request.form.get("text", "").strip()

        if text:
            # ML model
            is_bully_ml = predict_is_bullying(text)

            # Apriori model
            apriori_bully, emojis_found, pattern = apriori_detect(text)

            # FINAL decision
            is_bully = is_bully_ml or apriori_bully

            if not is_bully:
                # save safe comment
                cur.execute(
                    "INSERT INTO comments (user_id, comment, prediction) VALUES (?, ?, 0)",
                    (user["id"], text),
                )
                conn.commit()
                message = "âœ… Comment posted successfully!"
                prediction = 0

            else:
                # WARNING counter
                new_cnt = user["bullying_count"] + 1

                cur.execute(
                    "UPDATE users SET bullying_count=? WHERE id=?",
                    (new_cnt, user["id"])
                )
                conn.commit()

                if apriori_bully:
                    message = f"âš  Bullying emoji detected "
                else:
                    message = f"âš  Bullying detected! Warning {new_cnt}/{BULLY_LIMIT}"

                prediction = 1

                # BLOCK user
                if new_cnt >= BULLY_LIMIT:
                    cur.execute("UPDATE users SET is_blocked=1 WHERE id=?", (user["id"],))
                    conn.commit()
                    conn.close()
                    return render_template("blocked.html", username=user["username"])

                # reload user
                cur.execute("SELECT * FROM users WHERE id=?", (user["id"],))
                user = cur.fetchone()

    # LOAD SAFE COMMENTS
    cur.execute("SELECT comment, created_at FROM comments WHERE prediction=0 ORDER BY created_at DESC")
    comments = cur.fetchall()
    conn.close()

    return render_template(
        "index.html",
        username=user["username"],
        message=message,
        prediction=prediction,
        bullying_count=user["bullying_count"],
        comments=comments
    )



if __name__ == "__main__":
    if not os.path.exists(DB_PATH):
        print("Database not found. Run: python create_db.py")
        raise SystemExit(1)

    print("Starting Flask app...")
    app.run(debug=True, host="127.0.0.1", port=5001)
